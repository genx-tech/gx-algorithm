{"version":3,"sources":["../src/Tree.js"],"sourcesContent":["const { _ } = require('@genx/july');\n\n/**\n * A closure function to be called to check the data of each node whether meets certain condition\n * @callback predicateFunction\n * @param {Node} node\n * @returns {boolean}\n */\n\n/**\n * Tree factory.\n * @param {Node} Node\n * @returns {Tree}\n */\nconst Tree = (Node) =>\n    class extends Node {\n        static Node = Node;\n\n        /**\n         * Find a node by BFS.\n         * @param {predicateFunction} predicate\n         */\n        find(predicate) {\n            let queue = Node.cloneChildrenList(this);\n\n            while (queue.length > 0) {\n                const node = queue.shift();\n\n                if (predicate(node)) return node;\n\n                queue = queue.concat(Node.cloneChildrenList(node));\n            }\n\n            return undefined;\n        }\n    };\n\n/**\n * Tree node with data property.\n * @class\n */\nclass DataNode {\n    static cloneChildrenList(node) {\n        return node.children.concat();\n    }\n\n    /**\n     * Array of children nodes.\n     * @member {array}\n     */\n    children = [];\n\n    /**\n     * Create a data node with given data.\n     * @param {*} data\n     */\n    constructor(data) {\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return this.children.length;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {DataNode} node\n     */\n    append(node) {\n        node.parent = this;\n        this.children.push(node);\n    }\n\n    /**\n     * Insert the given node at specified index in the children list.\n     * @param {number} i\n     * @param {DataNode} node\n     */\n    insert(i, node) {\n        node.parent = this;\n        this.children.splice(Math.max(0, i), 0, node);\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {DataNode} node\n     * @returns {DataNode}\n     */\n    remove(node) {\n        if (node.parent !== this) {\n            throw new Error(\n                'Removing a node which is not a child of the current node.'\n            );\n        }\n\n        this.children = _.reject(this.children, (n) => n === node);\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Remove the node at the given index from the branch.\n     * @param {number} i\n     * @returns {DataNode}\n     */\n    removeAtIndex(i) {\n        const [removed] = this.children.splice(i, 1);\n        if (removed) {\n            delete removed.parent;\n        }\n\n        return removed;\n    }\n}\n\n/**\n * Tree node with key property and data property.\n * @class\n */\nclass KeyDataNode {\n    static cloneChildrenList(node) {\n        return Object.values(node.children);\n    }\n\n    /**\n     * Map of keys to children nodes.\n     * @member {object}\n     */\n    children = {};\n\n    /**\n     * Create a key-data node with key and given data.\n     * @param {string} key\n     * @param {*} data\n     */\n    constructor(key, data) {\n        /**\n         * Node key.\n         * @member {string}\n         */\n        this.key = key;\n\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return Object.keys(this.children).length;\n    }\n\n    /**\n     * Fina a node by path being an array of keys.\n     * @param {array.<string>} keys\n     */\n    findByKeyPath(keys) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            return undefined;\n        }\n\n        let value = { children: { [this.key]: this } };\n\n        _.find(keys, (key) => {\n            value = value.children[key];\n            return typeof value === 'undefined';\n        });\n\n        return value;\n    }\n\n    /**\n     * Append data by path being an array of keys.\n     * @param {array.<string>} keys\n     * @param {*} data\n     * @returns {KeyDataNode} The newly created node containing the data.\n     */\n    appendDataByKeyPath(keys, data) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            throw new Error(\n                `The given key path \"${keys.join(\n                    ' / '\n                )}\" is not starting from the correct initial key \"${this.key}\".`\n            );\n        }\n\n        const lastKey = keys.pop();\n        let lastNode = { children: { [this.key]: this } };\n        let node;\n\n        _.each(keys, (key) => {\n            if (key in lastNode.children) {\n                lastNode = lastNode.children[key];\n            } else {\n                node = new KeyDataNode(key);\n                lastNode.append(node);\n                lastNode = node;\n            }\n        });\n\n        node = new KeyDataNode(lastKey, data);\n        lastNode.append(node);\n\n        return node;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {KeyDataNode} node\n     */\n    append(node) {\n        node.parent = this;\n\n        if (node.key in this.children) {\n            throw new Error(`Duplicate node key: ${node.key}`);\n        }\n\n        this.children[node.key] = node;\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {KeyDataNode} node\n     */\n    remove(node) {\n        if (node.parent !== this || !(node.key in this.children)) {\n            throw new Error(\n                'Removing a node which is not a child of the current node.'\n            );\n        }\n\n        delete this.children[node.key];\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Get key path of current node (a key chain from root to itself).\n     * @returns {array}\n     */\n    getKeyPath() {\n        const paths = [this.key];\n        let curr = this;\n\n        while (curr.parent) {\n            curr = curr.parent;\n            paths.push(curr.key);\n        }\n\n        return paths.reverse();\n    }\n}\n\nmodule.exports = {\n    Tree: Tree(DataNode),\n    KeyTree: Tree(KeyDataNode),\n};\n"],"names":["_","require","Tree","Node","find","predicate","queue","cloneChildrenList","length","node","shift","concat","undefined","DataNode","children","constructor","data","size","append","parent","push","insert","i","splice","Math","max","remove","Error","reject","n","removeAtIndex","removed","KeyDataNode","Object","values","key","keys","findByKeyPath","value","appendDataByKeyPath","join","lastKey","pop","lastNode","each","getKeyPath","paths","curr","reverse","module","exports","KeyTree"],"mappings":"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"}