{"version":3,"sources":["FiniteStateMachine.js"],"names":["eachAsync_","require","InvalidArgument","Forbidden","FiniteStateMachine","constructor","app","transitionTable","stateFetcher","stateUpdater","transitions","stateFetcher_","stateUpdater_","getAllowedActions_","context","withDisallowedReason","currentState","allowed","disallowed","rule","action","actionAllowed","disallowedReason","when","OK","push","desc","targetState","target","reason","ret","performAction_","payload","updateOpts","connOpts","entityUpdate","before","actuallyUpdated","updateResult","after","array","args","action_","l","length","i","checker_","fail","join","module","exports"],"mappings":"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","sourcesContent":["const { eachAsync_ } = require('@genx/july');\nconst { InvalidArgument, Forbidden } = require('@genx/error');\n\n/**\n *\n * Action rule:\n *  desc: description of this transition\n *  when: pre transition condition check\n *  target: target state\n *  before: transforming before applying to the state\n *  after: trigger another action after transition\n */\n\nclass FiniteStateMachine {\n    static OK = [true];\n    static fail = (reason) => [false, reason];\n    static triggerAll_ =\n        (array) =>\n        (...args) =>\n            eachAsync_(array, (action_) => action_(...args));\n\n    static ifAny =\n        (array) =>\n        async (...args) => {\n            const l = array.length;\n                const reason = [];\n\n            for (let i = 0; i < l; i++) {\n                const checker_ = array[i];\n\n                const [allowed, disallowedReason] = await checker_(...args);\n                if (allowed) {\n                    return FiniteStateMachine.OK;\n                }\n\n                reason.push(disallowedReason);\n            }\n\n            return FiniteStateMachine.fail(\n                'None of the required conditions met.\\n' + reason.join('\\n')\n            );\n        };\n\n    static ifAll =\n        (array) =>\n        async (...args) => {\n            const l = array.length;\n\n            for (let i = 0; i < l; i++) {\n                const checker_ = array[i];\n\n                const [allowed, disallowedReason] = await checker_(...args);\n                if (!allowed) {\n                    return FiniteStateMachine.fail(disallowedReason);\n                }\n            }\n\n            return FiniteStateMachine.OK;\n        };\n\n    constructor(app, transitionTable, stateFetcher, stateUpdater) {\n        this.app = app;\n\n        this.transitions = transitionTable;\n        this.stateFetcher_ = stateFetcher;\n        this.stateUpdater_ = stateUpdater;\n    }\n\n    /**\n     * Get a list of allowed actions based on the current state.\n     * @param {*} context\n     * @param {boolean} withDisallowedReason\n     */\n    async getAllowedActions_(context, withDisallowedReason) {\n        const currentState = await this.stateFetcher_(this.app, context);\n\n        // from state\n        const transitions = this.transitions[currentState];\n        if (!transitions) {\n            throw new InvalidArgument(\n                `State \"${currentState}\" rules not found in the transition table.`\n            );\n        }\n\n        const allowed = [];\n            const disallowed = [];\n\n        await eachAsync_(transitions, async (rule, action) => {\n            const [actionAllowed, disallowedReason] =\n                (rule.when && (await rule.when(this.app, context))) ||\n                FiniteStateMachine.OK;\n\n            if (actionAllowed) {\n                allowed.push({\n                    action,\n                    desc: rule.desc,\n                    targetState: rule.target,\n                });\n            } else if (withDisallowedReason) {\n                disallowed.push({\n                    action,\n                    desc: rule.desc,\n                    targetState: rule.target,\n                    reason: disallowedReason,\n                });\n            }\n        });\n\n        const ret = {\n            allowed,\n        };\n\n        if (withDisallowedReason) {\n            ret.disallowed = disallowed;\n        }\n\n        return ret;\n    }\n\n    /**\n     * Perform the specified action.\n     * @param {*} action\n     * @param {*} context\n     * @param {*} payload\n     * @param {*} updateOpts\n     * @param {*} connOpts\n     */\n    async performAction_(action, context, payload, updateOpts, connOpts) {\n        const currentState = await this.stateFetcher_(\n            this.app,\n            context,\n            connOpts\n        );\n\n        const transitions = this.transitions[currentState];\n        if (!transitions) {\n            throw new InvalidArgument(\n                `State \"${currentState}\" rules not found in the transition table.`\n            );\n        }\n\n        const rule = transitions && transitions[action];\n        if (!rule) {\n            throw new Forbidden(\n                `Action \"${action}\" is not allowed in \"${currentState}\" state.`\n            );\n        }\n\n        if (rule.when) {\n            const [allowed, disallowedReason] = await rule.when(\n                this.app,\n                context\n            );\n            if (!allowed) {\n                throw new Forbidden(\n                    disallowedReason ||\n                        `The current state does not meet the requirements of \"${action}\" action.`\n                );\n            }\n        }\n\n        const entityUpdate = (rule.before &&\n            (await rule.before(this.app, context, payload))) || { ...payload };\n        const [actuallyUpdated, updateResult] = await this.stateUpdater_(\n            this.app,\n            context,\n            entityUpdate,\n            rule.target,\n            updateOpts,\n            connOpts\n        );\n\n        if (actuallyUpdated && rule.after) {\n            await rule.after(this.app, context, connOpts);\n        }\n\n        return updateResult;\n    }\n}\n\nmodule.exports = FiniteStateMachine;\n"]}