{"version":3,"sources":["../src/Tree.js"],"sourcesContent":["const { _ } = require('@genx/july');\n\n/**\n * A closure function to be called to check the data of each node whether meets certain condition\n * @callback predicateFunction\n * @param {Node} node\n * @returns {boolean}\n */\n\n/**\n * Tree factory.\n * @param {Node} Node\n * @returns {Tree}\n */\nconst Tree = (Node) =>\n    class extends Node {\n        static Node = Node;\n\n        /**\n         * Find a node by BFS.\n         * @param {predicateFunction} predicate\n         */\n        find(predicate) {\n            let queue = Node.cloneChildrenList(this);\n\n            while (queue.length > 0) {\n                const node = queue.shift();\n\n                if (predicate(node)) return node;\n\n                queue = queue.concat(Node.cloneChildrenList(node));\n            }\n\n            return undefined;\n        }\n    };\n\n/**\n * Tree node with data property.\n * @class\n */\nclass DataNode {\n    static cloneChildrenList(node) {\n        return node.children.concat();\n    }\n\n    /**\n     * Array of children nodes.\n     * @member {array}\n     */\n    children = [];\n\n    /**\n     * Create a data node with given data.\n     * @param {*} data\n     */\n    constructor(data) {\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return this.children.length;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {DataNode} node\n     */\n    append(node) {\n        node.parent = this;\n        this.children.push(node);\n    }\n\n    /**\n     * Insert the given node at specified index in the children list.\n     * @param {number} i\n     * @param {DataNode} node\n     */\n    insert(i, node) {\n        node.parent = this;\n        this.children.splice(Math.max(0, i), 0, node);\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {DataNode} node\n     * @returns {DataNode}\n     */\n    remove(node) {\n        if (node.parent !== this) {\n            throw new Error(\n                'Removing a node which is not a child of the current node.'\n            );\n        }\n\n        this.children = _.reject(this.children, (n) => n === node);\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Remove the node at the given index from the branch.\n     * @param {number} i\n     * @returns {DataNode}\n     */\n    removeAtIndex(i) {\n        const [removed] = this.children.splice(i, 1);\n        if (removed) {\n            delete removed.parent;\n        }\n\n        return removed;\n    }\n}\n\n/**\n * Tree node with key property and data property.\n * @class\n */\nclass KeyDataNode {\n    static cloneChildrenList(node) {\n        return Object.values(node.children);\n    }\n\n    /**\n     * Map of keys to children nodes.\n     * @member {object}\n     */\n    children = {};\n\n    /**\n     * Create a key-data node with key and given data.\n     * @param {string} key\n     * @param {*} data\n     */\n    constructor(key, data) {\n        /**\n         * Node key.\n         * @member {string}\n         */\n        this.key = key;\n\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return Object.keys(this.children).length;\n    }\n\n    /**\n     * Fina a node by path being an array of keys.\n     * @param {array.<string>} keys\n     */\n    findByKeyPath(keys) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            return undefined;\n        }\n\n        let value = { children: { [this.key]: this } };\n\n        _.find(keys, (key) => {\n            value = value.children[key];\n            return typeof value === 'undefined';\n        });\n\n        return value;\n    }\n\n    /**\n     * Append data by path being an array of keys.\n     * @param {array.<string>} keys\n     * @param {*} data\n     * @returns {KeyDataNode} The newly created node containing the data.\n     */\n    appendDataByKeyPath(keys, data) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            throw new Error(\n                `The given key path \"${keys.join(\n                    ' / '\n                )}\" is not starting from the correct initial key \"${this.key}\".`\n            );\n        }\n\n        const lastKey = keys.pop();\n        let lastNode = { children: { [this.key]: this } };\n        let node;\n\n        _.each(keys, (key) => {\n            if (key in lastNode.children) {\n                lastNode = lastNode.children[key];\n            } else {\n                node = new KeyDataNode(key);\n                lastNode.append(node);\n                lastNode = node;\n            }\n        });\n\n        node = new KeyDataNode(lastKey, data);\n        lastNode.append(node);\n\n        return node;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {KeyDataNode} node\n     */\n    append(node) {\n        node.parent = this;\n\n        if (node.key in this.children) {\n            throw new Error(`Duplicate node key: ${node.key}`);\n        }\n\n        this.children[node.key] = node;\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {KeyDataNode} node\n     */\n    remove(node) {\n        if (node.parent !== this || !(node.key in this.children)) {\n            throw new Error(\n                'Removing a node which is not a child of the current node.'\n            );\n        }\n\n        delete this.children[node.key];\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Get key path of current node (a key chain from root to itself).\n     * @returns {array}\n     */\n    getKeyPath() {\n        const paths = [this.key];\n        let curr = this;\n\n        while (curr.parent) {\n            curr = curr.parent;\n            paths.push(curr.key);\n        }\n\n        return paths.reverse();\n    }\n}\n\nmodule.exports = {\n    Tree: Tree(DataNode),\n    KeyTree: Tree(KeyDataNode),\n};\n"],"names":["_","require","Tree","Node","find","predicate","queue","cloneChildrenList","length","node","shift","concat","undefined","DataNode","children","size","append","parent","push","insert","i","splice","Math","max","remove","Error","reject","n","removeAtIndex","removed","constructor","data","KeyDataNode","Object","values","keys","findByKeyPath","key","value","appendDataByKeyPath","join","lastKey","pop","lastNode","each","getKeyPath","paths","curr","reverse","module","exports","KeyTree"],"mappings":"AAAA;;;;;;;;;;;;;AAAA,MAAM,EAAEA,CAAC,CAAA,EAAE,GAAGC,OAAO,CAAC,YAAY,CAAC,AAAC;AAEpC;;;;;GAKG,CAEH;;;;GAIG,CACH,MAAMC,IAAI,GAAG,CAACC,IAAI;IACd,IAAA,SAAA,qBAAcA,IAAI;QAGd;;;WAGG,CACHC,IAAI,CAACC,SAAS,EAAE;YACZ,IAAIC,KAAK,GAAGH,IAAI,CAACI,iBAAiB,CAAC,IAAI,CAAC,AAAC;YAEzC,MAAOD,KAAK,CAACE,MAAM,GAAG,CAAC,CAAE;gBACrB,MAAMC,IAAI,GAAGH,KAAK,CAACI,KAAK,EAAE,AAAC;gBAE3B,IAAIL,SAAS,CAACI,IAAI,CAAC,EAAE,OAAOA,IAAI,CAAC;gBAEjCH,KAAK,GAAGA,KAAK,CAACK,MAAM,CAACR,IAAI,CAACI,iBAAiB,CAACE,IAAI,CAAC,CAAC,CAAC;aACtD;YAED,OAAOG,SAAS,CAAC;SACpB;KACJ;IAnBG,wBAAOT,MAAI,EAAGA,IAAI,CAAC;;CAmBtB,AAAC;AAEN;;;GAGG,CACH,IAAA,AAAMU,QAAQ,GAAd,MAAMA,QAAQ;IACV,OAAON,iBAAiB,CAACE,IAAI,EAAE;QAC3B,OAAOA,IAAI,CAACK,QAAQ,CAACH,MAAM,EAAE,CAAC;KACjC;IAoBD;;;OAGG,CACH,IAAII,IAAI,GAAG;QACP,OAAO,IAAI,CAACD,QAAQ,CAACN,MAAM,CAAC;KAC/B;IAED;;;OAGG,CACHQ,MAAM,CAACP,IAAI,EAAE;QACTA,IAAI,CAACQ,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAACH,QAAQ,CAACI,IAAI,CAACT,IAAI,CAAC,CAAC;KAC5B;IAED;;;;OAIG,CACHU,MAAM,CAACC,CAAC,EAAEX,IAAI,EAAE;QACZA,IAAI,CAACQ,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAACH,QAAQ,CAACO,MAAM,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEH,CAAC,CAAC,EAAE,CAAC,EAAEX,IAAI,CAAC,CAAC;KACjD;IAED;;;;OAIG,CACHe,MAAM,CAACf,IAAI,EAAE;QACT,IAAIA,IAAI,CAACQ,MAAM,KAAK,IAAI,EAAE;YACtB,MAAM,IAAIQ,KAAK,CACX,2DAA2D,CAC9D,CAAC;SACL;QAED,IAAI,CAACX,QAAQ,GAAGd,CAAC,CAAC0B,MAAM,CAAC,IAAI,CAACZ,QAAQ,EAAE,CAACa,CAAC,GAAKA,CAAC,KAAKlB,IAAI,CAAC,CAAC;QAC3D,OAAOA,IAAI,CAACQ,MAAM,CAAC;QAEnB,OAAOR,IAAI,CAAC;KACf;IAED;;;;OAIG,CACHmB,aAAa,CAACR,CAAC,EAAE;QACb,MAAM,CAACS,OAAO,CAAC,GAAG,IAAI,CAACf,QAAQ,CAACO,MAAM,CAACD,CAAC,EAAE,CAAC,CAAC,AAAC;QAC7C,IAAIS,OAAO,EAAE;YACT,OAAOA,OAAO,CAACZ,MAAM,CAAC;SACzB;QAED,OAAOY,OAAO,CAAC;KAClB;IArED;;;OAGG,CACHC,YAAYC,IAAI,CAAE;QAVlB;;;OAGG,CACHjB,sBAAAA,UAAQ,EAAG,EAAE,CAAC,CAAA;QAOV;;;WAGG,CACH,IAAI,CAACiB,IAAI,GAAGA,IAAI,CAAC;KACpB;CA4DJ;AAED;;;GAGG,CACH,IAAA,AAAMC,WAAW,GAAjB,MAAMA,WAAW;IACb,OAAOzB,iBAAiB,CAACE,IAAI,EAAE;QAC3B,OAAOwB,MAAM,CAACC,MAAM,CAACzB,IAAI,CAACK,QAAQ,CAAC,CAAC;KACvC;IA2BD;;;OAGG,CACH,IAAIC,IAAI,GAAG;QACP,OAAOkB,MAAM,CAACE,IAAI,CAAC,IAAI,CAACrB,QAAQ,CAAC,CAACN,MAAM,CAAC;KAC5C;IAED;;;OAGG,CACH4B,aAAa,CAACD,IAAI,EAAE;QAChBA,IAAI,GAAGA,IAAI,CAACxB,MAAM,EAAE,CAAC;QAErB,IAAIwB,IAAI,CAAC3B,MAAM,KAAK,CAAC,IAAI2B,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAACE,GAAG,EAAE;YAC3C,OAAOzB,SAAS,CAAC;SACpB;QAED,IAAI0B,KAAK,GAAG;YAAExB,QAAQ,EAAE;gBAAE,CAAC,IAAI,CAACuB,GAAG,CAAC,EAAE,IAAI;aAAE;SAAE,AAAC;QAE/CrC,CAAC,CAACI,IAAI,CAAC+B,IAAI,EAAE,CAACE,GAAG,GAAK;YAClBC,KAAK,GAAGA,KAAK,CAACxB,QAAQ,CAACuB,GAAG,CAAC,CAAC;YAC5B,OAAO,OAAOC,KAAK,KAAK,WAAW,CAAC;SACvC,CAAC,CAAC;QAEH,OAAOA,KAAK,CAAC;KAChB;IAED;;;;;OAKG,CACHC,mBAAmB,CAACJ,IAAI,EAAEJ,IAAI,EAAE;QAC5BI,IAAI,GAAGA,IAAI,CAACxB,MAAM,EAAE,CAAC;QAErB,IAAIwB,IAAI,CAAC3B,MAAM,KAAK,CAAC,IAAI2B,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAACE,GAAG,EAAE;YAC3C,MAAM,IAAIZ,KAAK,CACX,CAAC,oBAAoB,EAAEU,IAAI,CAACK,IAAI,CAC5B,KAAK,CACR,CAAC,gDAAgD,EAAE,IAAI,CAACH,GAAG,CAAC,EAAE,CAAC,CACnE,CAAC;SACL;QAED,MAAMI,OAAO,GAAGN,IAAI,CAACO,GAAG,EAAE,AAAC;QAC3B,IAAIC,QAAQ,GAAG;YAAE7B,QAAQ,EAAE;gBAAE,CAAC,IAAI,CAACuB,GAAG,CAAC,EAAE,IAAI;aAAE;SAAE,AAAC;QAClD,IAAI5B,IAAI,AAAC;QAETT,CAAC,CAAC4C,IAAI,CAACT,IAAI,EAAE,CAACE,GAAG,GAAK;YAClB,IAAIA,GAAG,IAAIM,QAAQ,CAAC7B,QAAQ,EAAE;gBAC1B6B,QAAQ,GAAGA,QAAQ,CAAC7B,QAAQ,CAACuB,GAAG,CAAC,CAAC;aACrC,MAAM;gBACH5B,IAAI,GAAG,IAAIuB,WAAW,CAACK,GAAG,CAAC,CAAC;gBAC5BM,QAAQ,CAAC3B,MAAM,CAACP,IAAI,CAAC,CAAC;gBACtBkC,QAAQ,GAAGlC,IAAI,CAAC;aACnB;SACJ,CAAC,CAAC;QAEHA,IAAI,GAAG,IAAIuB,WAAW,CAACS,OAAO,EAAEV,IAAI,CAAC,CAAC;QACtCY,QAAQ,CAAC3B,MAAM,CAACP,IAAI,CAAC,CAAC;QAEtB,OAAOA,IAAI,CAAC;KACf;IAED;;;OAGG,CACHO,MAAM,CAACP,IAAI,EAAE;QACTA,IAAI,CAACQ,MAAM,GAAG,IAAI,CAAC;QAEnB,IAAIR,IAAI,CAAC4B,GAAG,IAAI,IAAI,CAACvB,QAAQ,EAAE;YAC3B,MAAM,IAAIW,KAAK,CAAC,CAAC,oBAAoB,EAAEhB,IAAI,CAAC4B,GAAG,CAAC,CAAC,CAAC,CAAC;SACtD;QAED,IAAI,CAACvB,QAAQ,CAACL,IAAI,CAAC4B,GAAG,CAAC,GAAG5B,IAAI,CAAC;KAClC;IAED;;;OAGG,CACHe,MAAM,CAACf,IAAI,EAAE;QACT,IAAIA,IAAI,CAACQ,MAAM,KAAK,IAAI,IAAI,CAAC,CAACR,IAAI,CAAC4B,GAAG,IAAI,IAAI,CAACvB,QAAQ,CAAC,EAAE;YACtD,MAAM,IAAIW,KAAK,CACX,2DAA2D,CAC9D,CAAC;SACL;QAED,OAAO,IAAI,CAACX,QAAQ,CAACL,IAAI,CAAC4B,GAAG,CAAC,CAAC;QAC/B,OAAO5B,IAAI,CAACQ,MAAM,CAAC;QAEnB,OAAOR,IAAI,CAAC;KACf;IAED;;;OAGG,CACHoC,UAAU,GAAG;QACT,MAAMC,KAAK,GAAG;YAAC,IAAI,CAACT,GAAG;SAAC,AAAC;QACzB,IAAIU,IAAI,GAAG,IAAI,AAAC;QAEhB,MAAOA,IAAI,CAAC9B,MAAM,CAAE;YAChB8B,IAAI,GAAGA,IAAI,CAAC9B,MAAM,CAAC;YACnB6B,KAAK,CAAC5B,IAAI,CAAC6B,IAAI,CAACV,GAAG,CAAC,CAAC;SACxB;QAED,OAAOS,KAAK,CAACE,OAAO,EAAE,CAAC;KAC1B;IAlID;;;;OAIG,CACHlB,YAAYO,GAAG,EAAEN,IAAI,CAAE;QAXvB;;;OAGG,CACHjB,sBAAAA,UAAQ,EAAG,EAAE,CAAC,CAAA;QAQV;;;WAGG,CACH,IAAI,CAACuB,GAAG,GAAGA,GAAG,CAAC;QAEf;;;WAGG,CACH,IAAI,CAACN,IAAI,GAAGA,IAAI,CAAC;KACpB;CAkHJ;AAEDkB,MAAM,CAACC,OAAO,GAAG;IACbhD,IAAI,EAAEA,IAAI,CAACW,QAAQ,CAAC;IACpBsC,OAAO,EAAEjD,IAAI,CAAC8B,WAAW,CAAC;CAC7B,CAAC"}