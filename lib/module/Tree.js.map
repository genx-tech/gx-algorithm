{"version":3,"sources":["Tree.js"],"names":["_","require","Tree","Node","find","predicate","queue","cloneChildrenList","length","node","shift","concat","undefined","DataNode","children","constructor","data","size","append","parent","push","insert","i","splice","Math","max","remove","Error","reject","n","removeAtIndex","removed","KeyDataNode","Object","values","key","keys","findByKeyPath","value","appendDataByKeyPath","join","lastKey","pop","lastNode","each","getKeyPath","paths","curr","reverse","module","exports","KeyTree"],"mappings":"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","sourcesContent":["const { _ } = require('@genx/july');\n\n/**\n * A closure function to be called to check the data of each node whether meets certain condition\n * @callback predicateFunction\n * @param {Node} node\n * @returns {boolean}\n */\n\n/**\n * Tree factory.\n * @param {Node} Node\n * @returns {Tree}\n */\nconst Tree = (Node) =>\n    class extends Node {\n        static Node = Node;\n\n        /**\n         * Find a node by BFS.\n         * @param {predicateFunction} predicate\n         */\n        find(predicate) {\n            let queue = Node.cloneChildrenList(this);\n\n            while (queue.length > 0) {\n                const node = queue.shift();\n\n                if (predicate(node)) return node;\n\n                queue = queue.concat(Node.cloneChildrenList(node));\n            }\n\n            return undefined;\n        }\n    };\n\n/**\n * Tree node with data property.\n * @class\n */\nclass DataNode {\n    static cloneChildrenList(node) {\n        return node.children.concat();\n    }\n\n    /**\n     * Array of children nodes.\n     * @member {array}\n     */\n    children = [];\n\n    /**\n     * Create a data node with given data.\n     * @param {*} data\n     */\n    constructor(data) {\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return this.children.length;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {DataNode} node\n     */\n    append(node) {\n        node.parent = this;\n        this.children.push(node);\n    }\n\n    /**\n     * Insert the given node at specified index in the children list.\n     * @param {number} i\n     * @param {DataNode} node\n     */\n    insert(i, node) {\n        node.parent = this;\n        this.children.splice(Math.max(0, i), 0, node);\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {DataNode} node\n     * @returns {DataNode}\n     */\n    remove(node) {\n        if (node.parent !== this) {\n            throw new Error(\n                'Removing a node which is not a child of the current node.'\n            );\n        }\n\n        this.children = _.reject(this.children, (n) => n === node);\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Remove the node at the given index from the branch.\n     * @param {number} i\n     * @returns {DataNode}\n     */\n    removeAtIndex(i) {\n        const [removed] = this.children.splice(i, 1);\n        if (removed) {\n            delete removed.parent;\n        }\n\n        return removed;\n    }\n}\n\n/**\n * Tree node with key property and data property.\n * @class\n */\nclass KeyDataNode {\n    static cloneChildrenList(node) {\n        return Object.values(node.children);\n    }\n\n    /**\n     * Map of keys to children nodes.\n     * @member {object}\n     */\n    children = {};\n\n    /**\n     * Create a key-data node with key and given data.\n     * @param {string} key\n     * @param {*} data\n     */\n    constructor(key, data) {\n        /**\n         * Node key.\n         * @member {string}\n         */\n        this.key = key;\n\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return Object.keys(this.children).length;\n    }\n\n    /**\n     * Fina a node by path being an array of keys.\n     * @param {array.<string>} keys\n     */\n    findByKeyPath(keys) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            return undefined;\n        }\n\n        let value = { children: { [this.key]: this } };\n\n        _.find(keys, (key) => {\n            value = value.children[key];\n            return typeof value === 'undefined';\n        });\n\n        return value;\n    }\n\n    /**\n     * Append data by path being an array of keys.\n     * @param {array.<string>} keys\n     * @param {*} data\n     * @returns {KeyDataNode} The newly created node containing the data.\n     */\n    appendDataByKeyPath(keys, data) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            throw new Error(\n                `The given key path \"${keys.join(\n                    ' / '\n                )}\" is not starting from the correct initial key \"${this.key}\".`\n            );\n        }\n\n        const lastKey = keys.pop();\n        let lastNode = { children: { [this.key]: this } };\n        let node;\n\n        _.each(keys, (key) => {\n            if (key in lastNode.children) {\n                lastNode = lastNode.children[key];\n            } else {\n                node = new KeyDataNode(key);\n                lastNode.append(node);\n                lastNode = node;\n            }\n        });\n\n        node = new KeyDataNode(lastKey, data);\n        lastNode.append(node);\n\n        return node;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {KeyDataNode} node\n     */\n    append(node) {\n        node.parent = this;\n\n        if (node.key in this.children) {\n            throw new Error(`Duplicate node key: ${node.key}`);\n        }\n\n        this.children[node.key] = node;\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {KeyDataNode} node\n     */\n    remove(node) {\n        if (node.parent !== this || !(node.key in this.children)) {\n            throw new Error(\n                'Removing a node which is not a child of the current node.'\n            );\n        }\n\n        delete this.children[node.key];\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Get key path of current node (a key chain from root to itself).\n     * @returns {array}\n     */\n    getKeyPath() {\n        const paths = [this.key];\n        let curr = this;\n\n        while (curr.parent) {\n            curr = curr.parent;\n            paths.push(curr.key);\n        }\n\n        return paths.reverse();\n    }\n}\n\nmodule.exports = {\n    Tree: Tree(DataNode),\n    KeyTree: Tree(KeyDataNode),\n};\n"]}