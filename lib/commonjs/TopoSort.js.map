{"version":3,"names":["_","require","TopoSort","add","dependency","newDependents","Array","isArray","dependents","mapOfDependents","forEach","dependent","dependencies","mapOfDependencies","Set","hasDependency","node","size","hasDependent","sort","l","nodesWithDependents","Object","keys","nodesWithDependencies","initialNodes","nodeHasDependency","delete","s","allNodes","concat","unsorted","numWithDependencies","mapValues","length","n","shift","push","dependentsOfN","dependentOfN","circular","Error","join","module","exports"],"sources":["TopoSort.js"],"sourcesContent":["'use strict';\n\nconst { _ } = require('@genx/july');\n\n/**\n * @class\n */\nclass TopoSort {\n    /**\n     * Map of nodes to a set of nodes as dependents, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependents = {};\n\n    /** -\n     * Map of nodes to a set of nodes as dependencies, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependencies = {};\n\n    /**\n     * Add edges(or one edge, if values is non-array).\n     * @param {string} dependency - Incoming node (dependency)\n     * @param {string|array} dependents - Outgoing node or nodes\n     */\n    add(dependency, newDependents) {\n        // cast to array\n        newDependents = Array.isArray(newDependents)\n            ? newDependents\n            : [newDependents];\n\n        // get the existing dependents\n        const dependents = this.mapOfDependents[dependency];\n\n        newDependents.forEach((dependent) => {\n            // get the existing dependencies\n            const dependencies = this.mapOfDependencies[dependent];\n            if (!dependencies) {\n                // new set of dependencies\n                this.mapOfDependencies[dependent] = new Set([dependency]);\n            } else {\n                dependencies.add(dependency);\n            }\n\n            if (dependents) {\n                dependents.add(dependent);\n            }\n        });\n\n        if (!dependents) {\n            // new set of dependents\n            this.mapOfDependents[dependency] = new Set(newDependents);\n        }\n    }\n\n    hasDependency(node) {\n        return (\n            (this.mapOfDependencies[node] &&\n                this.mapOfDependencies[node].size > 0) ||\n            false\n        );\n    }\n\n    hasDependent(node) {\n        return (\n            (this.mapOfDependents[node] &&\n                this.mapOfDependents[node].size > 0) ||\n            false\n        );\n    }\n\n    /**\n     * Sort the graph. Circular graph throw an error with the circular nodes info.\n     * Implementation of http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\n     * Reference: http://courses.cs.washington.edu/courses/cse326/03wi/lectures/RaoLect20.pdf\n     * @return {Array} Sorted list\n     */\n    sort() {\n        // The list contains the final sorted nodes.\n        const l = [];\n\n        // Find all the initial 0 incoming edge nodes. If not found, this is is a circular graph, cannot be sorted.\n        const nodesWithDependents = Object.keys(this.mapOfDependents);\n        const nodesWithDependencies = Object.keys(this.mapOfDependencies);\n\n        const initialNodes = new Set(nodesWithDependents);\n        nodesWithDependencies.forEach((nodeHasDependency) =>\n            initialNodes.delete(nodeHasDependency)\n        );\n\n        // List of nodes with no unsorted dependencies\n        const s = [...initialNodes];\n\n        const allNodes = new Set(\n            nodesWithDependents.concat(nodesWithDependencies)\n        );\n\n        // number of unsorted nodes. If it is not zero at the end, this graph is a circular graph and cannot be sorted.\n        let unsorted = allNodes.size;\n\n        const numWithDependencies = _.mapValues(\n            this.mapOfDependencies,\n            (node) => node.size\n        );\n\n        while (s.length !== 0) {\n            const n = s.shift();\n            l.push(n);\n\n            // decrease unsorted count, node n has been sorted.\n            --unsorted;\n\n            // n node might have no dependency, so have to check it.\n            const dependentsOfN = this.mapOfDependents[n];\n            if (dependentsOfN) {\n                // decease n's adjacent nodes' incoming edges count. If any of them has 0 incoming edges, push them into s get them ready for detaching from the graph.\n                for (const dependentOfN of dependentsOfN) {\n                    if (--numWithDependencies[dependentOfN] === 0) {\n                        // no unsorted dependencies\n                        s.push(dependentOfN);\n                    }\n                }\n            }\n        }\n\n        // If there are unsorted nodes left, this graph is a circular graph and cannot be sorted.\n        // At least 1 circular dependency exist in the nodes with non-zero incoming edges.\n        if (unsorted !== 0) {\n            const circular = [];\n\n            for (const node in numWithDependencies) {\n                if (numWithDependencies[node] !== 0) {\n                    circular.push(node);\n                }\n            }\n\n            throw new Error(\n                'At least 1 circular dependency in nodes: \\n\\n' +\n                    circular.join('\\n') +\n                    '\\n\\nGraph cannot be sorted!'\n            );\n        }\n\n        return l;\n    }\n}\n\nmodule.exports = TopoSort;\n"],"mappings":"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"}